#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "ArdestanIDs.h"
#include "AutoGeneratedHeader.h"
#include "Ardestan.h"

#include "arobj_trigger.h"
#include "/home/iid/Desktop/Ardestan/projnew/dfplayer_mini/arobj_dfplayer_mini.hpp"
#include "arobj_select.h"
#include "arobj_int.h"
#include "arobj_toggle.h"
#include "arobj_loadbang.h"
#include "arobj_dout.h"
#include "arobj_din_change.h"

constexpr long REQUIRED_MEMORY_SPACE_FOR_OBJECTS =
    sizeof(ARObjDfplayerMini) * 1 +
    sizeof(ARObjDinChange) * 1 +
    sizeof(ARObjTrigger) * 1 +
    sizeof(ARObjToggle) * 1 +
    sizeof(ARObjDout) * 1;

uint8_t        g_memory_space[REQUIRED_MEMORY_SPACE_FOR_OBJECTS];

uint32_t       g_timer_callback_timestamp[NUM_OF_EVENT_SCHEDULING_OBJECTS];

ARObject       g_objects[9];
ARValue        g_inlets[12];

AROutlets      g_outlets[9] = {
    {0, 1},
    {1, 1},
    {2, 1},
    {3, 1},
    {4, 0},
    {4, 1},
    {5, 2},
    {7, 0},
    {7, 1},
};

ARConnection   g_connections[8] = {
    {0, 8, 0},
    {0, 6, 0},
    {0, 7, 1},
    {0, 7, 0},
    {0, 4, 0},
    {1, 2, 0},
    {0, 3, 0},
    {0, 5, 0},
};

void setup(void)
{
    uint8_t *p_alloc = g_memory_space;
    ARValue *p_inlet = g_inlets;

    ARStr   *p_arstr = NULL;

    ARMessageType argTypes [2];
    ARValue       argValues[2];

    g_objects[0].init(p_alloc, trigger_func_din_change, 0, p_inlet);
    argTypes [0] = ARMessageType::INT;
    argValues[0].i = 8;
    init_func_din_change(&(g_objects[0]), p_alloc, 1, argTypes, argValues);
    p_alloc += sizeof(ARObjDinChange);
    p_inlet += 0;

    g_objects[1].init(p_alloc, trigger_func_loadbang, 1, p_inlet);
    init_func_loadbang(&(g_objects[1]), p_alloc, 0, NULL, NULL);
    p_inlet += 1;

    g_objects[2].init(p_alloc, trigger_func_int, 2, p_inlet);
    argTypes [0] = ARMessageType::INT;
    argValues[0].i = 40;
    init_func_int(&(g_objects[2]), p_alloc, 1, argTypes, argValues);
    p_inlet += 2;

    g_objects[3].init(p_alloc, trigger_func_int, 2, p_inlet);
    argTypes [0] = ARMessageType::INT;
    argValues[0].i = 1;
    init_func_int(&(g_objects[3]), p_alloc, 1, argTypes, argValues);
    p_inlet += 2;

    g_objects[4].init(p_alloc, trigger_func_dout, 1, p_inlet);
    argTypes [0] = ARMessageType::INT;
    argValues[0].i = 13;
    init_func_dout(&(g_objects[4]), p_alloc, 1, argTypes, argValues);
    p_alloc += sizeof(ARObjDout);
    p_inlet += 1;

    g_objects[5].init(p_alloc, trigger_func_toggle, 1, p_inlet);
    init_func_toggle(&(g_objects[5]), p_alloc, 0, NULL, NULL);
    p_alloc += sizeof(ARObjToggle);
    p_inlet += 1;

    g_objects[6].init(p_alloc, trigger_func_trigger, 1, p_inlet);
    argTypes [0] = ARMessageType::SYM_ID;
    argValues[0].sym_id = ID_B;
    argTypes [1] = ARMessageType::SYM_ID;
    argValues[1].sym_id = ID_B;
    init_func_trigger(&(g_objects[6]), p_alloc, 2, argTypes, argValues);
    p_alloc += sizeof(ARObjTrigger);
    p_inlet += 1;

    g_objects[7].init(p_alloc, trigger_func_dfplayer_mini, 2, p_inlet, false);
    argTypes [0] = ARMessageType::INT;
    argValues[0].i = 10;
    argTypes [1] = ARMessageType::INT;
    argValues[1].i = 11;
    init_func_dfplayer_mini(&(g_objects[7]), p_alloc, 2, argTypes, argValues);
    p_alloc += sizeof(ARObjDfplayerMini);
    p_inlet += 2;

    g_objects[8].init(p_alloc, trigger_func_select, 2, p_inlet);
    argTypes [0] = ARMessageType::INT;
    argValues[0].i = 0;
    init_func_select(&(g_objects[8]), p_alloc, 1, argTypes, argValues);
    p_inlet += 2;


    ARValue sym_loadbang;
    sym_loadbang.sym_id = ID_LOADBANG;

    //initialize the timer callback timestamp to __UINT32_MAX__ (0xFFFFFFFF)
    memset(g_timer_callback_timestamp, 0xFF, sizeof(g_timer_callback_timestamp));

    set_now(millis());

    //trigger loadbang objects.
    for (int i = NUM_OF_POLLING_OBJECTS + NUM_OF_EVENT_SCHEDULING_OBJECTS; i < NUM_OF_POLLING_OBJECTS + NUM_OF_EVENT_SCHEDULING_OBJECTS + NUM_OF_LOADBANG_OBJECTS; i++){
        g_objects[i].input(0, ARMessageType::SYM_ID, sym_loadbang);
    }

    set_now(millis());

}


void loop(void)
{
    ARValue sym_polling;
    sym_polling.sym_id = ID_POLL;

    //trigger the polling objects every cycle.
    for (int i = NUM_OF_EVENT_SCHEDULING_OBJECTS; i < NUM_OF_EVENT_SCHEDULING_OBJECTS + NUM_OF_POLLING_OBJECTS; i++){
        g_objects[i].input(0, ARMessageType::SYM_ID, sym_polling);
    }

    //process the scheduled timer callack events.
    uint32_t current_logical_time;
    uint32_t real_time = millis();


    #if (NUM_OF_EVENT_SCHEDULING_OBJECTS > 0)
        //process scheduled events.
        current_logical_time = process_scheduled_timer_callback(real_time);
    #else
        //if the time has been wound back (the time counter overflow),
        //just halt the system.
        if (real_time < now()){
            current_logical_time = __UINT32_MAX__;
        }
        else {
            set_now(real_time);
            current_logical_time = real_time;
        }
    #endif

    //halt the system if the time has been reached.
    while(current_logical_time == __UINT32_MAX__);

}
